<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README.rdoc</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README.rdoc</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README.rdoc
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Thu Jan 31 19:03:07 -0700 2013</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1><a href="../classes/JSON.html">JSON</a> implementation for Ruby <a href="http://travis-ci.org/flori/json"><img src="https://secure.travis-ci.org/flori/json.png" /></a></h1>
<h2>Description</h2>
<p>
This is a implementation of the <a href="../classes/JSON.html">JSON</a>
specification according to RFC 4627 <a
href="http://www.ietf.org/rfc/rfc4627.txt">www.ietf.org/rfc/rfc4627.txt</a>
. Starting from version 1.0.0 on there will be two variants available:
</p>
<ul>
<li>A pure ruby variant, that relies on the iconv and the stringscan
extensions, which are both part of the ruby standard library.

</li>
<li>The quite a bit faster C extension variant, which is in parts implemented
in C and comes with its own unicode conversion functions and a parser
generated by the ragel state machine compiler <a
href="http://www.cs.queensu.ca/~thurston/ragel">www.cs.queensu.ca/~thurston/ragel</a>
.

</li>
</ul>
<p>
Both variants of the <a href="../classes/JSON.html">JSON</a> generator
generate UTF-8 character sequences by default. If an :ascii_only option
with a true value is given, they escape all non-ASCII and control
characters with \uXXXX escape sequences, and support UTF-16 surrogate pairs
in order to be able to generate the whole range of unicode code points.
</p>
<p>
All strings, that are to be encoded as <a
href="../classes/JSON.html">JSON</a> strings, should be UTF-8 byte
sequences on the Ruby side. To encode raw binary strings, that aren&#8216;t
UTF-8 encoded, please use the to_json_raw_object method of String (which
produces an object, that contains a byte array) and decode the result on
the receiving endpoint.
</p>
<p>
The <a href="../classes/JSON.html">JSON</a> parsers can parse UTF-8,
UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE <a
href="../classes/JSON.html">JSON</a> documents under Ruby 1.8. Under Ruby
1.9 they take advantage of Ruby&#8216;s M17n features and can parse all
documents which have the correct String#encoding set. If a document string
has ASCII-8BIT as an encoding the parser attempts to figure out which of
the UTF encodings from above it is and trys to parse it.
</p>
<h2>Installation</h2>
<p>
It&#8216;s recommended to use the extension variant of <a
href="../classes/JSON.html">JSON</a>, because it&#8216;s faster than the
pure ruby variant. If you cannot build it on your system, you can settle
for the latter.
</p>
<p>
Just type into the command line as root:
</p>
<pre>
  # rake install
</pre>
<p>
The above command will build the extensions and install them on your
system.
</p>
<pre>
  # rake install_pure
</pre>
<p>
or
</p>
<pre>
  # ruby install.rb
</pre>
<p>
will just install the pure ruby implementation of <a
href="../classes/JSON.html">JSON</a>.
</p>
<p>
If you use Rubygems you can type
</p>
<pre>
  # gem install json
</pre>
<p>
instead, to install the newest <a href="../classes/JSON.html">JSON</a>
version.
</p>
<p>
There is also a pure ruby json only variant of the gem, that can be
installed with:
</p>
<pre>
  # gem install json_pure
</pre>
<h2>Compiling the extensions yourself</h2>
<p>
If you want to build the extensions yourself you need rake:
</p>
<pre>
  You can get it from rubyforge:
    http://rubyforge.org/projects/rake

  or just type

  # gem install rake

  for the installation via rubygems.
</pre>
<p>
If you want to create the parser.c file from its parser.rl file or draw
nice graphviz images of the state machines, you need ragel from: <a
href="http://www.cs.queensu.ca/~thurston/ragel">www.cs.queensu.ca/~thurston/ragel</a>
</p>
<h2>Usage</h2>
<p>
To use <a href="../classes/JSON.html">JSON</a> you can
</p>
<pre>
  require 'json'
</pre>
<p>
to load the installed variant (either the extension &#8216;json&#8217; or
the pure variant &#8216;json_pure&#8217;). If you have installed the
extension variant, you can pick either the extension variant or the pure
variant by typing
</p>
<pre>
  require 'json/ext'
</pre>
<p>
or
</p>
<pre>
  require 'json/pure'
</pre>
<p>
Now you can parse a <a href="../classes/JSON.html">JSON</a> document into a
ruby data structure by calling
</p>
<pre>
  JSON.parse(document)
</pre>
<p>
If you want to generate a <a href="../classes/JSON.html">JSON</a> document
from a ruby data structure call
</p>
<pre>
  JSON.generate(data)
</pre>
<p>
You can also use the pretty_generate method (which formats the output more
verbosely and nicely) or fast_generate (which doesn&#8216;t do any of the
security checks generate performs, e. g. nesting deepness checks).
</p>
<p>
To create a valid <a href="../classes/JSON.html">JSON</a> document you have
to make sure, that the output is embedded in either a <a
href="../classes/JSON.html">JSON</a> array [] or a <a
href="../classes/JSON.html">JSON</a> object {}. The easiest way to do this,
is by putting your values in a Ruby Array or Hash instance.
</p>
<p>
There are also the <a href="../classes/JSON.html">JSON</a> and <a
href="../classes/JSON.html">JSON</a>[] methods which use parse on a String
or generate a <a href="../classes/JSON.html">JSON</a> document from an
array or hash:
</p>
<pre>
  document = JSON 'test'  =&gt; 23 # =&gt; &quot;{\&quot;test\&quot;:23}&quot;
  document = JSON['test'] =&gt; 23 # =&gt; &quot;{\&quot;test\&quot;:23}&quot;
</pre>
<p>
and
</p>
<pre>
  data = JSON '{&quot;test&quot;:23}'  # =&gt; {&quot;test&quot;=&gt;23}
  data = JSON['{&quot;test&quot;:23}'] # =&gt; {&quot;test&quot;=&gt;23}
</pre>
<p>
You can choose to load a set of common additions to ruby core&#8216;s
objects if you
</p>
<pre>
  require 'json/add/core'
</pre>
<p>
After requiring this you can, e. g., serialise/deserialise Ruby ranges:
</p>
<pre>
  JSON JSON(1..10) # =&gt; 1..10
</pre>
<p>
To find out how to add <a href="../classes/JSON.html">JSON</a> support to
other or your own classes, read the section &quot;More Examples&quot;
below.
</p>
<p>
To get the best compatibility to rails&#8217; <a
href="../classes/JSON.html">JSON</a> implementation, you can
</p>
<pre>
  require 'json/add/rails'
</pre>
<p>
Both of the additions attempt to require &#8216;json&#8217; (like above)
first, if it has not been required yet.
</p>
<h2>More Examples</h2>
<p>
To create a <a href="../classes/JSON.html">JSON</a> document from a ruby
data structure, you can call <a
href="../classes/JSON.html#M000041">JSON.generate</a> like that:
</p>
<pre>
 json = JSON.generate [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10]
 # =&gt; &quot;[1,2,{\&quot;a\&quot;:3.141},false,true,null,\&quot;4..10\&quot;]&quot;
</pre>
<p>
To get back a ruby data structure from a <a
href="../classes/JSON.html">JSON</a> document, you have to call <a
href="../classes/JSON.html#M000039">JSON.parse</a> on it:
</p>
<pre>
 JSON.parse json
 # =&gt; [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, &quot;4..10&quot;]
</pre>
<p>
Note, that the range from the original data structure is a simple string
now. The reason for this is, that <a href="../classes/JSON.html">JSON</a>
doesn&#8216;t support ranges or arbitrary classes. In this case the json
library falls back to call Object#to_json, which is the same as
to_s.to_json.
</p>
<p>
It&#8216;s possible to add <a href="../classes/JSON.html">JSON</a> support
serialization to arbitrary classes by simply implementing a more
specialized version of the to_json method, that should return a <a
href="../classes/JSON.html">JSON</a> object (a hash converted to <a
href="../classes/JSON.html">JSON</a> with to_json) like this (don&#8216;t
forget the *a for all the arguments):
</p>
<pre>
 class Range
   def to_json(*a)
     {
       'json_class'   =&gt; self.class.name, # = 'Range'
       'data'         =&gt; [ first, last, exclude_end? ]
     }.to_json(*a)
   end
 end
</pre>
<p>
The hash key &#8216;json_class&#8217; is the class, that will be asked to
deserialise the <a href="../classes/JSON.html">JSON</a> representation
later. In this case it&#8216;s &#8216;<a
href="../classes/Range.html">Range</a>&#8217;, but any namespace of the
form &#8216;A::B&#8217; or &#8217;::A::B&#8217; will do. All other keys are
arbitrary and can be used to store the necessary data to configure the
object to be deserialised.
</p>
<p>
If a the key &#8216;json_class&#8217; is found in a <a
href="../classes/JSON.html">JSON</a> object, the <a
href="../classes/JSON.html">JSON</a> parser checks if the given class
responds to the json_create class method. If so, it is called with the <a
href="../classes/JSON.html">JSON</a> object converted to a Ruby hash. So a
range can be deserialised by implementing <a
href="../classes/Range.html#M000035">Range.json_create</a> like this:
</p>
<pre>
 class Range
   def self.json_create(o)
     new(*o['data'])
   end
 end
</pre>
<p>
Now it possible to serialise/deserialise ranges as well:
</p>
<pre>
 json = JSON.generate [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10]
 # =&gt; &quot;[1,2,{\&quot;a\&quot;:3.141},false,true,null,{\&quot;json_class\&quot;:\&quot;Range\&quot;,\&quot;data\&quot;:[4,10,false]}]&quot;
 JSON.parse json
 # =&gt; [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10]
</pre>
<p>
<a href="../classes/JSON.html#M000041">JSON.generate</a> always creates the
shortest possible string representation of a ruby data structure in one
line. This is good for data storage or network protocols, but not so good
for humans to read. Fortunately there&#8216;s also <a
href="../classes/JSON.html#M000043">JSON.pretty_generate</a> (or <a
href="../classes/JSON.html#M000043">JSON.pretty_generate</a>) that creates
a more readable output:
</p>
<pre>
 puts JSON.pretty_generate([1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10])
 [
   1,
   2,
   {
     &quot;a&quot;: 3.141
   },
   false,
   true,
   null,
   {
     &quot;json_class&quot;: &quot;Range&quot;,
     &quot;data&quot;: [
       4,
       10,
       false
     ]
   }
 ]
</pre>
<p>
There are also the methods Kernel#j for generate, and Kernel#jj for
pretty_generate output to the console, that work analogous to Core
Ruby&#8216;s p and the pp library&#8216;s pp methods.
</p>
<p>
The script tools/server.rb contains a small example if you want to test,
how receiving a <a href="../classes/JSON.html">JSON</a> object from a
webrick server in your browser with the javasript prototype library <a
href="http://www.prototypejs.org">www.prototypejs.org</a> works.
</p>
<h2>Speed Comparisons</h2>
<p>
I have created some benchmark results (see the benchmarks/data-p4-3Ghz
subdir of the package) for the <a
href="../classes/JSON.html">JSON</a>-parser to estimate the speed up in the
C extension:
</p>
<pre>
 Comparing times (call_time_mean):
  1 ParserBenchmarkExt#parser   900 repeats:
        553.922304770 (  real) -&gt;   21.500x
          0.001805307
  2 ParserBenchmarkYAML#parser  1000 repeats:
        224.513358139 (  real) -&gt;    8.714x
          0.004454078
  3 ParserBenchmarkPure#parser  1000 repeats:
         26.755020642 (  real) -&gt;    1.038x
          0.037376163
  4 ParserBenchmarkRails#parser 1000 repeats:
         25.763381731 (  real) -&gt;    1.000x
          0.038814780
            calls/sec (  time) -&gt;    speed  covers
            secs/call
</pre>
<p>
In the table above 1 is JSON::Ext::Parser, 2 is YAML.load with YAML
compatbile <a href="../classes/JSON.html">JSON</a> document, 3 is is <a
href="../classes/JSON/Pure/Parser.html">JSON::Pure::Parser</a>, and 4 is
ActiveSupport::JSON.decode. The ActiveSupport <a
href="../classes/JSON.html">JSON</a>-decoder converts the input first to
YAML and then uses the YAML-parser, the conversion seems to slow it down so
much that it is only as fast as the <a
href="../classes/JSON/Pure/Parser.html">JSON::Pure::Parser</a>!
</p>
<p>
If you look at the benchmark data you can see that this is mostly caused by
the frequent high outliers - the median of the Rails-parser runs is still
overall smaller than the median of the <a
href="../classes/JSON/Pure/Parser.html">JSON::Pure::Parser</a> runs:
</p>
<pre>
 Comparing times (call_time_median):
  1 ParserBenchmarkExt#parser   900 repeats:
        800.592479481 (  real) -&gt;   26.936x
          0.001249075
  2 ParserBenchmarkYAML#parser  1000 repeats:
        271.002390644 (  real) -&gt;    9.118x
          0.003690004
  3 ParserBenchmarkRails#parser 1000 repeats:
         30.227910865 (  real) -&gt;    1.017x
          0.033082008
  4 ParserBenchmarkPure#parser  1000 repeats:
         29.722384421 (  real) -&gt;    1.000x
          0.033644676
            calls/sec (  time) -&gt;    speed  covers
            secs/call
</pre>
<p>
I have benchmarked the <a href="../classes/JSON.html">JSON</a>-Generator as
well. This generated a few more values, because there are different modes
that also influence the achieved speed:
</p>
<pre>
 Comparing times (call_time_mean):
  1 GeneratorBenchmarkExt#generator_fast    1000 repeats:
        547.354332608 (  real) -&gt;   15.090x
          0.001826970
  2 GeneratorBenchmarkExt#generator_safe    1000 repeats:
        443.968212317 (  real) -&gt;   12.240x
          0.002252414
  3 GeneratorBenchmarkExt#generator_pretty  900 repeats:
        375.104545883 (  real) -&gt;   10.341x
          0.002665923
  4 GeneratorBenchmarkPure#generator_fast   1000 repeats:
         49.978706968 (  real) -&gt;    1.378x
          0.020008521
  5 GeneratorBenchmarkRails#generator       1000 repeats:
         38.531868759 (  real) -&gt;    1.062x
          0.025952543
  6 GeneratorBenchmarkPure#generator_safe   1000 repeats:
         36.927649925 (  real) -&gt;    1.018x 7 (&gt;=3859)
          0.027079979
  7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:
         36.272134441 (  real) -&gt;    1.000x 6 (&gt;=3859)
          0.027569373
            calls/sec (  time) -&gt;    speed  covers
            secs/call
</pre>
<p>
In the table above 1-3 are JSON::Ext::Generator methods. 4, 6, and 7 are <a
href="../classes/JSON/Pure/Generator.html">JSON::Pure::Generator</a>
methods and 5 is the Rails <a href="../classes/JSON.html">JSON</a>
generator. It is now a bit faster than the generator_safe and
generator_pretty methods of the pure variant but slower than the others.
</p>
<p>
To achieve the fastest <a href="../classes/JSON.html">JSON</a> document
output, you can use the fast_generate method. Beware, that this will
disable the checking for circular Ruby data structures, which may cause <a
href="../classes/JSON.html">JSON</a> to go into an infinite loop.
</p>
<p>
Here are the median comparisons for completeness&#8217; sake:
</p>
<pre>
 Comparing times (call_time_median):
  1 GeneratorBenchmarkExt#generator_fast    1000 repeats:
        708.258020939 (  real) -&gt;   16.547x
          0.001411915
  2 GeneratorBenchmarkExt#generator_safe    1000 repeats:
        569.105020353 (  real) -&gt;   13.296x
          0.001757145
  3 GeneratorBenchmarkExt#generator_pretty  900 repeats:
        482.825371244 (  real) -&gt;   11.280x
          0.002071142
  4 GeneratorBenchmarkPure#generator_fast   1000 repeats:
         62.717626652 (  real) -&gt;    1.465x
          0.015944481
  5 GeneratorBenchmarkRails#generator       1000 repeats:
         43.965681162 (  real) -&gt;    1.027x
          0.022745013
  6 GeneratorBenchmarkPure#generator_safe   1000 repeats:
         43.929073409 (  real) -&gt;    1.026x 7 (&gt;=3859)
          0.022763968
  7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:
         42.802514491 (  real) -&gt;    1.000x 6 (&gt;=3859)
          0.023363113
            calls/sec (  time) -&gt;    speed  covers
            secs/call
</pre>
<h2>Author</h2>
<p>
Florian Frank &lt;<a href="mailto:flori@ping.de">flori@ping.de</a>&gt;
</p>
<h2>License</h2>
<p>
Ruby License, see the COPYING file included in the source distribution. The
Ruby License includes the GNU General Public License (GPL), Version 2, so
see the file GPL as well.
</p>
<h2>Download</h2>
<p>
The latest version of this library can be downloaded at
</p>
<ul>
<li><a
href="http://rubyforge.org/frs?group_id=953">rubyforge.org/frs?group_id=953</a>

</li>
</ul>
<p>
Online Documentation should be located at
</p>
<ul>
<li><a href="http://json.rubyforge.org">json.rubyforge.org</a>

</li>
</ul>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>